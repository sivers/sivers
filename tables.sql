--------- functions needed by table definitions:

create function crypt(text, text) returns text as '$libdir/pgcrypto', 'pg_crypt' language c immutable strict;
create function gen_salt(text, integer) returns text as '$libdir/pgcrypto', 'pg_gen_salt_rounds' language c strict;
create function gen_random_bytes(integer) returns bytea as '$libdir/pgcrypto', 'pg_random_bytes' language c strict;

-- used by many functions for random strings
create function random_string(length integer) returns text as $$
declare
	chars text[] = '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
	result text = '';
	i integer = 0;
	rand bytea;
begin
	-- generate secure random bytes and convert them to a string of chars.
	rand = gen_random_bytes($1);
	for i in 0..length-1 loop
		-- rand indexing is zero-based, chars is 1-based.
		result = result || chars[1 + (get_byte(rand, i) % array_length(chars, 1))];
	end loop;
	return result;
end;
$$ language plpgsql;

-- make confirmed-unique random strings in a given table.field
-- returns random string confirmed to not be used yet in given tablename.fieldname
create function unique_random(str_len integer, table_name text, field_name text) returns text as $$
declare
	nu text;
	rowcount integer;
begin
	nu = random_string($1);
	loop
		execute format('select 1 from %s where %I = %L', $2, $3, nu);
		get diagnostics rowcount = row_count;
		if rowcount = 0 then
			return nu; 
		end if;
		nu = random_string($1);
	end loop;
end;
$$ language plpgsql;

--------- TABLES:

-- configs for other companies' APIs and such. k = key, v = value
create table configs (
	k text not null primary key check (length(k) > 0),
	v text not null check (length(v) > 0)
);

-- languages, for validation in other tables
create table langs (
	code char(2) not null primary key check (length(code) = 2), -- ISO 639-1
	code3 char(3) not null unique check (length(code3) = 3), -- ISO 639-3
	language text not null check (length(language) > 0), -- display
	dir char(3) not null default 'ltr' check (dir in ('ltr', 'rtl')) --- HTML direction
);

-- country codes: foreign key constraint on people.country, invoices.country, etc.
create table countries (
	code character(2) not null primary key check (length(code) = 2),
	name text not null check (length(name) > 0)
);

-- UI convenience for showing and normalizing people.state
create table states (
	country char(2) not null,  -- references countries(code)
	code text not null check (length(code) > 0),
	name text not null check (length(name) > 0),
	primary key (country, code)
);
create index on states(country);

create table currencies (
    code char(3) not null primary key check (length(code) = 3),
	name text not null check (length(name) > 0),
	fx numeric not null,
	fxdate date not null,
	fmt text not null check (length(fmt) > 0),
	round2 smallint not null default 2 -- decimal places to round prices to
);

-- which countries use which currency
create table country_currency (
	country char(2) not null, -- references countries(code)
	currency char(3) not null, -- references currencies(code)
	primary key (country, currency)
);

-- map range of IP addresses to country code, saved in stats
create table ips (
	ip1 inet not null,
	ip2 inet not null,
	country char(2) not null, -- references countries(code)
	primary key (ip1, ip2)
);

-- most used table
create table people (
	id integer primary key generated by default as identity,
	created_at date not null default current_date,
	lopass char(4) unique default unique_random(4, 'people', 'lopass'),
	name text not null check (length(name) > 0),
	greeting text, -- trigger generates to first word of name, if null
	company text,
	city text,
	state text,
	country char(2), -- references countries(code)
	phone text,
	notes text not null default '',
	categorize_as varchar(16),
	email_count integer not null default 0 -- # of incoming emails
);

-- people with administrator access log in with a password
create table admins (
	person_id integer primary key, -- references people(id)
	hashpass text
);

-- which apps is this admin allowed to access?
create table admin_auths (
	person_id integer not null, -- references people(id)
	appcode varchar(5), -- API schema name
	primary key (person_id, appcode)
);

-- people's email addresses  ("at" is a shorter name for email_address)
-- queries should often use string_agg(ats.email, ',') as email
create table ats (
	email text primary key constraint valid_email check (email ~ '\A\S+@\S+\.\S+\Z'),
	person_id integer not null, -- references people(id)
	used timestamptz(0) default now(), -- when did they last use it?
	listype varchar(4) check (length(listype) > 0)
);
create index atp on ats(person_id);
create index on ats(listype);

-- This person's websites
create table urls (
	id integer primary key generated by default as identity,
	person_id integer not null, -- references people(id)
	url text not null constraint url_format check (url ~ '^https?://[0-9a-zA-Z_-]+\.[a-zA-Z0-9]+'),
	main boolean  -- true it's their main/home site
);
create index on urls(person_id);

-- private tags (for admin eyes only)  (rename "ourtags"?)
create table ptags (
	person_id integer not null, -- references people(id)
	tag text not null check (length(tag) > 0),
	very boolean,
	created_at date default current_date,
	primary key (person_id, tag)
);
create index on ptags(person_id);
create index on ptags(tag);

-- people's self-tags ("utags" = "user tags") (rename "usertags"?)
create table utags (
	person_id integer not null, -- references people(id)
	tag text not null check (length(tag) > 0),
	created_at date default current_date,
	primary key (person_id, tag)
);
create index on utags(person_id);
create index on utags(tag);

-- Catch-all for any random facts about this person
create table stats (
	id integer primary key generated by default as identity,
	person_id integer not null, -- references people(id)
	statkey text not null check (statkey ~ '\A[a-z0-9._-]+\Z'),
	statvalue text not null check (length(statvalue) > 0),
	created_at date not null default current_date
);
create index on stats(person_id);
create index on stats(statkey);

-- expiring link, emailed
-- if not in people then add email and name here, add to people if they log in
create table temps (
	temp char(16) not null primary key default unique_random(16, 'temps', 'temp'),
	person_id integer unique, -- references people(id)
	new_email text unique check (new_email ~ '\A\S+@\S+\.\S+\Z'),
	new_name text check (length(new_name) > 0),
	expires timestamptz(0) default (now() + interval '1 month')
);
create index on temps(expires);

-- people with administrator access log in with a password
create table logins (
	cookie char(32) primary key default random_string(32),
	person_id integer not null unique, -- references people(id)
	created_at date not null default current_date
);

create table emails (
	id integer primary key generated by default as identity,
	person_id integer, -- references people(id) -- null if new & not yet assigned
	category varchar(16) not null check (length(category) > 0),  -- like gmail's labels, but 1-to-1
	created_at timestamptz(0) not null default current_timestamp,
	created_by integer,
	opened_at timestamptz(0),
	opened_by integer,
	closed_at timestamptz(0),
	closed_by integer,
	reference_id integer, -- references emails(id) -- email this is replying to
	their_email text not null check (their_email ~ '\A\S+@\S+\.\S+\Z'), -- their email address
	their_name text not null,
	subject text,
	headers text,
	body text,
	message_id text unique,
	outgoing boolean default 'f'
);
create index on emails(person_id);
create index on emails(outgoing);
create index on emails(category);
create index on emails(opened_by);

-- attachments sent with incoming emails
create table attachments (
	id smallint primary key generated by default as identity,
	email_id integer, -- references emails(id)
	mime_type text,
	filename text,
	bytes integer
);
create index on attachments(email_id);

-- commonly used emails.body templates
create table formletters (
	id smallint primary key generated by default as identity,
	accesskey char(1) unique check (accesskey ~ '[a-z0-9]'),
	title text unique check (length(title) > 0),
	explanation text,
	subject text,
	body text check (length(body) > 0),
	created_at date not null default current_date
);

-- query populats listpeople while referencing this id, example:
-- select 1, email from ats where listype='all'
create table lists (
	id smallint primary key generated by default as identity,
	name text unique,
	query text
);

create table listpeople (
	id text primary key, -- message_id of email!
	list_id smallint not null, -- references lists(id)
	email text not null,  -- references ats(email)
	subject text,
	body text,
	emailed timestamptz(0) -- update when confirmed sent 
);
create index on listpeople(list_id);
create index on listpeople(emailed);

create table interviews (
	id integer primary key generated by default as identity,
	uri text unique, -- public/publish if not null
	person_id integer, -- references people(id)
	ymdhm timestamp without time zone, -- TODO: with time zone and set to their chosen time: select ymdhm at time zone 'America/New_York' 
	name text,  -- name of podcast
	host text,
	their_url text, -- after they publish it
	notes text,   -- private
	summary text, -- public
	mp3 text,
	mp4 text
);

-- interview segments
create type uttertype as enum('question', 'answer', 'statement', 'idle');
create table utterances (
	code char(8) primary key default unique_random(8, 'utterances', 'code'),
	interview_id integer not null,-- references interviews(id),
	seconds integer not null, -- sort by this. duration into mp3, or step by 10 if no audio
	utype uttertype,
	response2 char(8), -- references utterances(code) -- links answer to its question
	highlight boolean not null default false,
	speaker varchar(24), -- "sivers" if me (remember sometimes two guests or two hosts)
	content text
);
create index on utterances(interview_id);

-- for interviews:
create table availabilities (
	id integer primary key generated by default as identity,
	startime timestamptz(0) not null,
	stoptime timestamptz(0) not null check (stoptime > startime),
	chosen timestamptz(0) check (startime <= chosen and stoptime >= chosen),
	person_id integer, -- references people(id)
	interview_id integer unique -- references interviews(id)
);

-- for in-person meetings
create table meetwheres (
	id integer primary key generated by default as identity,
	location text, -- name and address to give to people I'm meeting
	display text, -- later public display like '2024-11 - Shenzhen, China'
	tzname varchar(32), -- 'America/Los_Angeles', 'Asia/Kolkata'
	thoughts text -- public, afterwards, about the place
);

create table meetings (
	id integer primary key generated by default as identity,
	where_id integer not null, -- references meetwheres(id)
	person_id integer not null, -- references people(id)
	whatime timestamptz(0),
	topics text, -- filled later for showing on site
	notes text -- public, afterwards, about our conversation
);

-- for meetings:
create table meetavails (
	id integer primary key generated by default as identity,
	where_id integer not null, -- references meetwheres(id)
	startime timestamptz(0) not null,
	stoptime timestamptz(0) not null check (stoptime > startime),
	person_id integer, -- references people(id)
	meeting_id integer unique -- references meetings(id)
);

-----------------------
---------- mynow + now:
-----------------------
create table now_pages (
	id smallint primary key generated by default as identity,
	person_id integer not null, -- references people(id)
	created_at date not null default current_date,
	updated_at date not null default current_date,
	review_at timestamptz, -- under review since and by...
	review_by integer, -- references people(id)
	checked_at date not null default current_date,
	checked_by integer, -- references people(id)
	flagged boolean default false,
	short text unique check (length(short) > 0),
	long text unique check (long ~ '^https?://[^/]+\..+'),
	look4 text -- text on their site TODO: null if ''
);
create index on now_pages(person_id);
create index on now_pages(review_by) where review_by is not null;
create index on now_pages(checked_at, id) where review_at is null;
create index on now_pages(flagged) where flagged is true;

create table now_profiles (
	id integer not null primary key, -- references people(id)
	public_id char(4) not null unique default unique_random(4, 'now_profiles', 'public_id'),
	photo boolean not null default false,
	title text,
	liner text,
	why text,
	thought text,
	red text
);

create table metabooks (
	id smallint primary key generated by default as identity,
	name text unique,
	title_code char(8),
	subtitle_code char(8),
	copyright text,
	aboutme text,
	bgcolor varchar(13),
	fgcolor varchar(13),
	has_sections boolean,
	show_chapter_title boolean -- at beginning of each chapter
);

-- metabook + language = book (used for selling not translating)
create table books (
	id smallint primary key generated by default as identity,
	metabook_id smallint not null, -- references metabooks(id)
	lang char(2), -- references langs(code)
	notes text
);
create index on books(metabook_id);

create table isbns (
	isbn varchar(17) primary key
);

-- books need formats (hardcover, audiobook, epub, etc)
create table formats (
	id smallint primary key generated by default as identity,
	book_id smallint not null, -- references books(id)
	format text not null,
	isbn varchar(17) unique,
	filename text
);

create table articles (
	id smallint primary key generated by default as identity,
	title text,
	original text,
	title_code char(8),  -- generated from title
	template text  -- generated from original
);

create table sentences (
	code char(8) primary key default unique_random(8, 'sentences', 'code'),
	article_id integer, -- references articles(id)
	sortid smallint, -- order by
	sentence text, 
	hint text  -- my comment to translators
);
create index on sentences(article_id);

create table hrefs (
	id integer primary key generated by default as identity,
	sentence_code char(8) not null, -- references sentences(code)
	placement smallint not null,
	url text
);

-- For books whose chapters are grouped into named sections
create table sections (
	id smallint primary key generated by default as identity,
	metabook_id smallint not null, -- references metabooks(id)
	sortid smallint,
	title_code char(8)
);
create index on sections(metabook_id);

-- Main sorting of articles into a book, whether with sections or not
create table chapters (
	metabook_id smallint not null, -- references metabooks(id)
	article_id smallint not null, -- references articles(id)
	section_id smallint, -- references sections(id)
	sortid smallint,
	primary key (metabook_id, article_id)
);

-- articles posted at sive.rs/{uri}
create table posts (
	uri varchar(16) primary key check (uri ~ '\A[a-z0-9-]+\Z'),
	article_id smallint not null unique, -- references articles(id)
	posted date
);

-- inchword.com login: person active and able to translate now. when done, delete.
create table translators (
	person_id integer primary key, -- references people(id)
	lang char(2) not null, -- references langs(code)
	metabook_id smallint -- to limit 1.inchword.com to show only articles from this
);

-- inchword.com login: person active and able to judge translations now. when done, delete.
create table transjury (
	person_id integer primary key, -- references people(id)
	lang char(2) not null -- references langs(code)
);

create table translations (
	id integer primary key generated by default as identity,
	sentence_code char(8) not null, -- references sentences(code)
	lang char(2) not null, -- references langs(code)
	by integer, -- references people(id)
	at timestamptz(0) not null default now(),
	active boolean default false, -- only one per sentence_code+lang
	status varchar(10) not null default 'translate', -- 'error', 'edit', 'edited', 'review', 'reviewed'
	translation text not null
);
create index on translations(sentence_code);
create index on translations(status);
create index on translations(active) where active = true;
create unique index on translations (lang, sentence_code) where (active is true); -- ensures only one active!

-- NOTE: Questions to me/author! No questions *for* the translator, only comments in judgements.
create table transquestions (
	id integer primary key generated by default as identity,
	translation_id integer, -- references translations(id)
	code char(8) not null, -- references sentences(code)
	by integer not null, -- references people(id)
	at timestamptz(0) not null default now(),
	question text not null,
	answer text
);
create index on transquestions(code);
create index on transquestions(by);

create table transjudgements (
	id integer primary key generated by default as identity,
	translation_id integer not null, -- references translations(id)
	by integer not null, -- references people(id)
	at timestamptz(0) not null default now(),
	good boolean,
	comment text
);
create index on transjudgements(translation_id);
create index on transjudgements(by);

create table comments (
	id integer primary key generated by default as identity,
	person_id integer not null, -- references people(id)
	uri text not null, -- references posts(uri)
	created_at date not null default current_date,
	name text check (length(name) > 0),
	email text check (email ~ '\A\S+@\S+\.\S+\Z'),
	comment text not null check (length(comment) > 0)
);
create index on comments(uri);
create index on comments(person_id);

create table videos (
	id integer primary key generated by default as identity,
	name text unique,
	filename text unique,
	seconds integer,
	youtube char(11),
	cdnid text
);

create table videotext (
	id integer primary key generated by default as identity,
	video_id integer not null,
	kind varchar(12), -- subtitles, chapters
	sentence_code char(8) not null,
	startime real,
	stoptime real
);
create index on videotext(video_id);
create index on videotext(startime);
create index on videotext(kind);

-- RSS 2.0
create table feeds (
	uri text not null primary key,
	podcast boolean not null default false,
	link text,
	title text not null,
	description text not null,
	ttl integer not null default 720, -- minutes to cache
	keywords text, -- for podcast
	imageurl text,
	category text,
	updated_at timestamptz(0) not null default current_timestamp
);

create table feeditems (
	uri text not null primary key,
	feed_uri text not null, -- references feeds(uri)
	pubdate timestamptz(0) not null default current_timestamp,
	article integer, -- references articles(id)
	ebook varchar(33), -- references ebooks(code)
	nowpage smallint, -- references now_pages(id)
	mediaurl text,
	bytes integer,
	seconds integer,
	title text, -- if no article_id
	content text -- if no article_id
);

-- usually entry is a fixed amount ('4 USD', '5.50 EUR') for postage
-- sometimes entry is a description: 'metaitem', 'gift-wrap hardcover', so
-- when I decide to charge a different amount for that item, I change usd here,
-- but keep the same ID# reference inside the app.
-- (id 1002 is always the price of a hardcover, id 1003 price of a paperback)
create table prices (
	id smallint primary key generated by default as identity,
	base char(3) not null default 'USD', -- references currencies(code) -- other currencies change around this
	info text, -- hardcover, initial digital, giftwrap
	usd numeric,
	cad numeric,
	eur numeric,
	gbp numeric,
	aud numeric,
	nzd numeric,
	brl numeric,
	inr numeric,
	sgd numeric,
	sek numeric,
	myr numeric,
	chf numeric,
	jpy numeric,
	cny numeric,
	zar numeric
);

-- like a metabook, ('Anything You Want', 'Useful Not True') for knowing which content they bought
-- (bought a hardcover or audiobook, still means they bought this metaitem)
create table metaitems (
	id smallint primary key generated by default as identity,
	name text not null unique,
	price_id smallint not null,
	description1 text, -- before item links (basic text)
	description2 text  -- after  (testimonials, etc)
);

create table items (
	id smallint primary key,
	metaitem_id smallint not null, -- references metaitems(id)
	available boolean not null default true,
	sku varchar(12) not null unique,
	name text not null,
	price_id smallint not null, -- references prices(id)
	weight numeric not null default 0, -- currently 0-or-1 for digital-or-physical (but could be grams?)
	stripeid char(19) unique  -- unique string assigned by Stripe.com
);
create index on items(metaitem_id);

create table warehouses (
	country char(2) not null primary key,
	address text,
	info text
);

-- log of items received by the warehouse. can be adjusted when auditing
create table warehoused (
	id integer primary key generated by default as identity,
	warehouse char(2) not null,
	item smallint not null,
	at date,
	howmany integer,
	note text
);

-- cached query of sum(howmany) from warehoused minus
-- sum(lineitems.quantity) where invoices.status in ('ship', 'done')
-- query this from sivers.com store before add-to-cart
create table stock (
	warehouse char(2) not null,
	item smallint not null,
	howmany integer,
	incart integer,
	primary key (warehouse, item)
);

create table invoices (
	id integer primary key generated by default as identity,
	person_id integer not null, -- references people(id)
	add2 integer unique, -- references invoices(id) -- ship with previous order
	created date not null default current_date,
	currency char(3) not null default 'USD', -- references currencies(code)
	warehouse char(2), -- references warehouses(country)
	shipcost numeric, -- (dynamic calculated) in invoices.currency
	total numeric check (total >= 0), -- (dynamic calculated) in invoices.currency
	payment numeric, -- in invoices.currency (set to equal total when paid)
	paydate date,
	payinfo text,
	status varchar(8) not null default 'cart',-- 'cart', 'ship', 'wait', 'problem', 'done'
	code char(8) unique default unique_random(8, 'invoices', 'code'), -- TODO: used anywhere?
	shipdate date,
	shipinfo text,
	shipname text,
	addr1 text,
	addr2 text,
	city text,
	state text,
	postcode text,
	country char(2),
	phone text,
	gift_note text
);
create index on invoices(person_id);
create index on invoices(status);

create table lineitems (
	id integer primary key generated by default as identity,
	invoice_id integer not null, -- references invoices(id)
	item_id smallint not null, -- references items(id)
	quantity smallint not null default 1 check (quantity > 0),
	price numeric not null default 0, -- (dynamic calculated) in invoices.currency
	unique(invoice_id, item_id)
);
create index on lineitems(invoice_id);
create index on lineitems(item_id);

-- postage prices, by zone and # of books
create table postrates (
	zone integer not null,
	books integer not null, -- for now just counting # of books instead of grams
	currency char(3) not null, -- references currencies(code)
	amount numeric, -- in postrates.currency
	primary key (zone, books)
);

-- from warehouse to their country = which postrates.zone?
create table postzones (
	warehouse char(2) not null, -- references warehouses(country)
	country char(2) not null, -- references countries(code)
	zone integer not null, -- references postrates(zone)
	primary key (warehouse, country)
);

create table downloadables (
	id smallint primary key generated by default as identity,
	metaitem_id smallint not null, -- references metaitems(id)
	filename text not null unique
);
create index on downloadables(metaitem_id);

create table praise (
	id integer primary key generated by default as identity,
	person_id integer not null, -- references people(id)
	metaitem_id smallint not null, -- references metaitems(id)
	created_at date not null default current_date,
	content text,
	placement smallint, -- 1=top, 999=not, null=awaiting ranking
	unique(person_id, metaitem_id)
);
create index on praise(person_id);
create index on praise(metaitem_id);

-- articles/videos/urls about my books
-- maybe should be called reviews? metamedia?
create table reactions (
	id integer primary key generated by default as identity,
	person_id integer, -- references people(id), null ok
	metaitem_id smallint not null, -- references metaitems(id)
	summary text,
	url text, -- their URL
	content text, -- keep local copy for when url disappears (transcribe audio)
	mp4 text  -- self-host video
);
create index on reactions(metaitem_id);

-- HTML for Mustache
create table templates (
	code varchar(32) primary key,
	template text
);

------- OTHER PEOPLE'S BOOKS: (sive.rs/book)
create table ebooks (
	code varchar(33) primary key,
	title text not null,
	author text not null,
	category varchar(10),
	isbn varchar(13),
	read date,
	rating smallint check (rating >= 0 and rating <= 10),
	summary text,
	refsme text  -- excerpt if it references me
);

-- chunked into topics that could stand alone
create table ebooknotes (
	id integer primary key generated by default as identity,
	ebook_code varchar(33) not null, -- references ebooks(code)
	sortid smallint not null,
	note text not null check (length(note) > 0)
);

